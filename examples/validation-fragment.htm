<!---
  Valibot Validation Fragment - Real Integration
  Provides optional data validation capabilities for <:data> elements
  Usage: <:import src="/lib/validation.htm" />
-->

<script type="module">
  // Real Valibot import from CDN
  import * as v from 'https://esm.sh/valibot@0.42.1';

  // Make Valibot available globally for use in reactive expressions
  globalThis.v = v;

  // Enhanced validation utilities
  globalThis.ValibotUtils = {
    // Convert Valibot ValiError to structured error object
    formatErrors(error) {
      const errors = {};

      if (error.issues) {
        for (const issue of error.issues) {
          const path = issue.path?.map(p => p.key).join('.') || '_root';
          errors[path] = issue.message;
        }
      } else {
        errors._root = error.message || 'Validation failed';
      }

      return errors;
    },

    // Safe parse wrapper that always returns success/errors structure
    safeParse(schema, data) {
      try {
        const result = v.safeParse(schema, data);
        return {
          success: result.success,
          data: result.success ? result.output : data,
          errors: result.success
            ? {}
            : this.formatErrors(
                result.issues
                  ? { issues: result.issues }
                  : new Error('Validation failed')
              ),
        };
      } catch (error) {
        return {
          success: false,
          data: data,
          errors: this.formatErrors(error),
        };
      }
    },

    // Create common schema patterns
    createUserSchema() {
      return v.object({
        name: v.pipe(
          v.string(),
          v.nonEmpty('Name is required'),
          v.maxLength(50, 'Name too long')
        ),
        email: v.pipe(
          v.string(),
          v.nonEmpty('Email is required'),
          v.email('Invalid email format')
        ),
        age: v.pipe(
          v.number(),
          v.minValue(18, 'Must be at least 18'),
          v.maxValue(120, 'Invalid age')
        ),
      });
    },

    createProductSchema() {
      return v.object({
        title: v.pipe(
          v.string(),
          v.nonEmpty('Title is required'),
          v.maxLength(100)
        ),
        price: v.pipe(v.number(), v.minValue(0, 'Price must be positive')),
        category: v.pipe(v.string(), v.nonEmpty('Category is required')),
        description: v.optional(
          v.pipe(v.string(), v.maxLength(500, 'Description too long'))
        ),
      });
    },

    createContactSchema() {
      return v.object({
        firstName: v.pipe(
          v.string(),
          v.nonEmpty('First name is required'),
          v.maxLength(30)
        ),
        lastName: v.pipe(
          v.string(),
          v.nonEmpty('Last name is required'),
          v.maxLength(30)
        ),
        email: v.pipe(
          v.string(),
          v.nonEmpty('Email is required'),
          v.email('Invalid email')
        ),
        phone: v.optional(
          v.pipe(
            v.string(),
            v.regex(/^\+?[\d\s\-\(\)]+$/, 'Invalid phone format')
          )
        ),
        message: v.pipe(
          v.string(),
          v.nonEmpty('Message is required'),
          v.maxLength(1000)
        ),
      });
    },
  };

  console.log('Valibot loaded and ready!', v);
</script>

<:define name="validated-data"> <:data :aka="validationService" :json="${{ //
Create a validation-enhanced data service using real Valibot
createValidatedData(options) { const { aka, src, json, schema, onValidation } =
options; // Enhanced data object with validation capabilities return { //
Original data properties src: src, json: json || {}, loading: false, //
Validation properties schema: schema, valid: true, errors: {}, lastValidated:
null, // Validation methods using real Valibot validate(data = this.json) { if
(!this.schema) return { success: true, data }; const result =
ValibotUtils.safeParse(this.schema, data); this.valid = result.success;
this.errors = result.errors; this.lastValidated = new Date().toISOString(); if
(result.success) { this.json = result.data; } // Optional validation callback if
(onValidation) { onValidation(result, this); } return result; }, // Safe getter
that always returns valid data get safeJson() { return this.valid ? this.json :
(json || {}); }, // Update method with automatic validation update(newData) {
const result = this.validate(newData); return result; }, // Patch method for
partial updates patch(updates) { const mergedData = { ...this.json, ...updates
}; return this.update(mergedData); }, // Field-level validation
validateField(fieldName, value) { if (!this.schema) return { success: true };
const testData = { ...this.json, [fieldName]: value }; const result =
ValibotUtils.safeParse(this.schema, testData); return { success:
!result.errors[fieldName], error: result.errors[fieldName] || null }; }, //
Reset to initial state reset() { this.json = { ...(json || {}) }; this.valid =
true; this.errors = {}; this.lastValidated = null; }, // Get field-specific
error getFieldError(fieldName) { return this.errors[fieldName] || null; }, //
Check if specific field is valid isFieldValid(fieldName) { return
!this.errors[fieldName]; } }; } }}" />
<!-- End of validated-data component -->

<!-- Real Valibot Usage Examples -->
<:define name="user-form-example">
<!-- Define validation schema using real Valibot -->
<:data :aka="userSchema" :json="${ValibotUtils.createUserSchema()}" />

<!-- Create validated data using the service -->
<:import src="#validated-data" /> <:data :aka="userForm"
:json="${validationService.json.createValidatedData({ aka: 'userForm', json: {
name: '', email: '', age: 18 }, schema: userSchema.json, onValidation: (result)
=> { console.log('User form validation:', result.success ? 'passed' : 'failed',
result.errors); } })}" />
<!-- End of user-form-example component -->

<!-- Form with validation -->
<form>
  <div>
    <label>Name:</label>
    <input
      :value="${userForm.json.json.name}"
      :on-input="${(e) => userForm.json.update({ ...userForm.json.json, name: e.target.value })}"
    />
    <span
      :class-error="${userForm.json.errors.name}"
      :style-display="${userForm.json.errors.name ? 'block' : 'none'}"
    >
      ${userForm.json.errors.name}
    </span>
  </div>

  <div>
    <label>Email:</label>
    <input
      :value="${userForm.json.json.email}"
      :on-input="${(e) => userForm.json.update({ ...userForm.json.json, email: e.target.value })}"
    />
    <span
      :class-error="${userForm.json.errors.email}"
      :style-display="${userForm.json.errors.email ? 'block' : 'none'}"
    >
      ${userForm.json.errors.email}
    </span>
  </div>

  <div>
    <label>Age:</label>
    <input
      type="number"
      :value="${userForm.json.json.age}"
      :on-input="${(e) => userForm.json.update({ ...userForm.json.json, age: parseInt(e.target.value) })}"
    />
    <span
      :class-error="${userForm.json.errors.age}"
      :style-display="${userForm.json.errors.age ? 'block' : 'none'}"
    >
      ${userForm.json.errors.age}
    </span>
  </div>

  <button type="submit" :disabled="${!userForm.json.valid}">Submit</button>
</form>

<div>
  <h3>Debug Info:</h3>
  <p>Valid: ${userForm.json.valid}</p>
  <p>Data: ${JSON.stringify(userForm.json.safeJson)}</p>
  <p>Errors: ${JSON.stringify(userForm.json.errors)}</p>
</div>
<!-- End of user-form-example -->
