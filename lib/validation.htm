<!---
  Production Valibot Integration Fragment
  Real-world implementation with actual Valibot integration
-->

<script type="module">
  // In a real implementation, this would dynamically import Valibot
  // import * as v from 'https://esm.sh/valibot@latest';

  // For now, we'll assume Valibot is available globally or imported elsewhere
  // This fragment provides the integration layer between Markout and Valibot
</script>

<:define name="valibot-service"> <:data :aka="valibot" :json="${{ // Main
validation service createValidator(schema, options = {}) { return { schema:
schema, validate: (data) => { try { // In real implementation: const result =
v.safeParse(schema, data); const result = this.mockValidate(schema, data);
return { success: result.success, data: result.success ? result.output : data,
errors: result.success ? {} : this.formatErrors(result.issues || [result.error])
}; } catch (error) { return { success: false, data: data, errors: { _root:
error.message } }; } } }; }, // Enhanced data factory with validation
validatedData(config) { const { schema, initialData = {}, onValidation,
...dataConfig } = config; const validator = schema ?
this.createValidator(schema) : null; return { // Standard data properties
...dataConfig, json: initialData, loading: false, // Validation state validator:
validator, valid: true, errors: {}, lastValidation: null, // Core validation
method validate(data = this.json) { if (!this.validator) return { success: true,
data }; const result = this.validator.validate(data); this.valid =
result.success; this.errors = result.errors; this.lastValidation = new Date();
if (result.success) { this.json = result.data; } // Optional callback for side
effects if (onValidation) { onValidation(result, this); } return result; }, //
Safe data access get safeData() { return this.valid ? this.json : initialData;
}, // Update with validation set(newData) { const result =
this.validate(newData); return result.success; }, // Partial update with
validation patch(updates) { const mergedData = { ...this.json, ...updates };
return this.set(mergedData); }, // Field-level validation
validateField(fieldName, value) { if (!this.validator || !this.validator.schema)
return { success: true }; const tempData = { ...this.json, [fieldName]: value };
const result = this.validate(tempData); // Return only field-specific error
return { success: !result.errors[fieldName], error: result.errors[fieldName] };
}, // Reset to initial state reset() { this.json = { ...initialData };
this.valid = true; this.errors = {}; this.lastValidation = null; } }; }, // Mock
validation for demonstration mockValidate(schema, data) { // This would be
replaced with actual Valibot validation // For demo purposes, just check basic
structure if (typeof data !== 'object') { return { success: false, error:
'Expected object' }; } return { success: true, output: data }; }, // Format
validation errors for UI display formatErrors(issues) { const errors = {}; if
(Array.isArray(issues)) { issues.forEach(issue => { const path =
issue.path?.join('.') || '_root'; errors[path] = issue.message || 'Validation
error'; }); } else if (typeof issues === 'string') { errors._root = issues; }
return errors; } }}" />
<!-- End of valibot-service component -->

<!-- Reusable form field component with validation -->
<:define name="validated-field">
<div class="field">
  <label>${label}:</label>
  <input
    :type="${type || 'text'}"
    :value="${value}"
    :on-input="${(e) => onInput(e.target.value)}"
    :class-invalid="${!!error}"
  />
  <span :class-error="${!!error}" :style-display="${error ? 'block' : 'none'}">
    ${error}
  </span>
</div>
<!-- End of validated-field component -->

<!-- Schema builder helpers -->
<:define name="common-schemas"> <:data :aka="schemas" :json="${{ user: { name:
'string|required|max:50', email: 'string|required|email', age:
'number|required|min:18|max:120' }, product: { title: 'string|required|max:100',
price: 'number|required|min:0', category: 'string|required' }, // Helper to
convert simple notation to Valibot schema // In real implementation, this would
create actual Valibot schemas build(definition) { return definition; //
Placeholder } }}" />
<!-- End of common-schemas component -->
